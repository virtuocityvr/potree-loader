{"version":3,"file":"decoder.worker.js","sources":["src/loading2/PointAttributes.ts","src/loading2/decoder.worker.js"],"sourcesContent":["/**\r\n * Some types of possible point attribute data formats\r\n *\r\n * @class\r\n */\r\nconst PointAttributeTypes:PointAttributeTypesType = {\r\n\tDATA_TYPE_DOUBLE: {ordinal: 0, name: \"double\", size: 8},\r\n\tDATA_TYPE_FLOAT:  {ordinal: 1, name: \"float\",  size: 4},\r\n\tDATA_TYPE_INT8:   {ordinal: 2, name: \"int8\",   size: 1},\r\n\tDATA_TYPE_UINT8:  {ordinal: 3, name: \"uint8\",  size: 1},\r\n\tDATA_TYPE_INT16:  {ordinal: 4, name: \"int16\",  size: 2},\r\n\tDATA_TYPE_UINT16: {ordinal: 5, name: \"uint16\", size: 2},\r\n\tDATA_TYPE_INT32:  {ordinal: 6, name: \"int32\",  size: 4},\r\n\tDATA_TYPE_UINT32: {ordinal: 7, name: \"uint32\", size: 4},\r\n\tDATA_TYPE_INT64:  {ordinal: 8, name: \"int64\",  size: 8},\r\n\tDATA_TYPE_UINT64: {ordinal: 9, name: \"uint64\", size: 8}\r\n};\r\n\r\ntype PointAttributeTypesType = {\r\n\t[key: string]: PointAttributeTypeType;\r\n};\r\n\r\ntype PointAttributeTypeType = {\r\n\tordinal: number;\r\n\tname: string;\r\n\tsize: number;\r\n};\r\n\r\nlet i = 0;\r\nfor (let obj in PointAttributeTypes) {\r\n\tPointAttributeTypes[i] = PointAttributeTypes[obj];\r\n\ti++;\r\n}\r\n\r\nexport {PointAttributeTypes};\r\n\r\ntype RangeType = number[] | [number[], number[]]\r\n\r\n// Class that represents a certain point attribute\r\nclass PointAttribute{\r\n\tbyteSize: number;\r\n\tdescription: string;\r\n\tpublic initialRange?: RangeType\r\n\r\n\tconstructor(\r\n\t\tpublic name:string,\r\n\t\tpublic type:PointAttributeTypeType,\r\n\t\tpublic numElements:number,\r\n\t\tpublic range: RangeType = [Infinity, -Infinity]\r\n\t){\r\n\t\tthis.byteSize = this.numElements * this.type.size;\r\n\t\tthis.description = \"\";\r\n\t}\r\n};\r\n\r\nexport {PointAttribute};\r\n\r\n// Map that represents all point attributes, these were previoiusly properties of the PointAttribute class\r\nexport const POINT_ATTRIBUTES:{[key:string]:PointAttribute} = {\r\n\tPOSITION_CARTESIAN: new PointAttribute(\"POSITION_CARTESIAN\", PointAttributeTypes.DATA_TYPE_FLOAT, 3),\r\n\tRGBA_PACKED: new PointAttribute(\"COLOR_PACKED\", PointAttributeTypes.DATA_TYPE_INT8, 4),\r\n\tCOLOR_PACKED: new PointAttribute(\"COLOR_PACKED\", PointAttributeTypes.DATA_TYPE_INT8, 4),\r\n\tRGB_PACKED: new PointAttribute(\"COLOR_PACKED\", PointAttributeTypes.DATA_TYPE_INT8, 3),\r\n\tNORMAL_FLOATS: new PointAttribute(\"NORMAL_FLOATS\", PointAttributeTypes.DATA_TYPE_FLOAT, 3),\r\n\tINTENSITY: new PointAttribute(\"INTENSITY\", PointAttributeTypes.DATA_TYPE_UINT16, 1),\r\n\tCLASSIFICATION: new PointAttribute(\"CLASSIFICATION\", PointAttributeTypes.DATA_TYPE_UINT8, 1),\r\n\tNORMAL_SPHEREMAPPED: new PointAttribute(\"NORMAL_SPHEREMAPPED\", PointAttributeTypes.DATA_TYPE_UINT8, 2),\r\n\tNORMAL_OCT16: new PointAttribute(\"NORMAL_OCT16\", PointAttributeTypes.DATA_TYPE_UINT8, 2),\r\n\tNORMAL: new PointAttribute(\"NORMAL\", PointAttributeTypes.DATA_TYPE_FLOAT, 3),\r\n\tRETURN_NUMBER: new PointAttribute(\"RETURN_NUMBER\", PointAttributeTypes.DATA_TYPE_UINT8, 1),\r\n\tNUMBER_OF_RETURNS: new PointAttribute(\"NUMBER_OF_RETURNS\", PointAttributeTypes.DATA_TYPE_UINT8, 1),\r\n\tSOURCE_ID: new PointAttribute(\"SOURCE_ID\", PointAttributeTypes.DATA_TYPE_UINT16, 1),\r\n\tINDICES: new PointAttribute(\"INDICES\", PointAttributeTypes.DATA_TYPE_UINT32, 1),\r\n\tSPACING: new PointAttribute(\"SPACING\", PointAttributeTypes.DATA_TYPE_FLOAT, 1),\r\n\tGPS_TIME: new PointAttribute(\"GPS_TIME\", PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\r\n}\r\n\r\ntype PAVectorType = {\r\n\tname: string;\r\n\tattributes: string[];\r\n}\r\n\r\n// Instantiated during loading\r\nexport class PointAttributes{\r\n\r\n\r\n\r\n\t// pointAttributes will be a list of strings\r\n\tconstructor(pointAttributes?:string[],\r\n\t\t\t\tpublic attributes:PointAttribute[] = [],\r\n\t\t\t\tpublic byteSize:number = 0,\r\n\t\t\t\tpublic size:number = 0,\r\n\t\t\t\tpublic vectors:PAVectorType[]=[]\r\n\t\t){\r\n\r\n\t\tif (pointAttributes != null) {\r\n\t\t\tfor (let i = 0; i < pointAttributes.length; i++) {\r\n\t\t\t\tlet pointAttributeName = pointAttributes[i];\r\n\t\t\t\tlet pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\r\n\t\t\t\tthis.attributes.push(pointAttribute);\r\n\t\t\t\tthis.byteSize += pointAttribute.byteSize;\r\n\t\t\t\tthis.size++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// I hate these argument names that are so similar to each other but have completely different types\r\n\tadd(pointAttribute:PointAttribute){\r\n\t\tthis.attributes.push(pointAttribute);\r\n\t\tthis.byteSize += pointAttribute.byteSize;\r\n\t\tthis.size++;\r\n\t};\r\n\r\n\taddVector(vector:PAVectorType){\r\n\t\tthis.vectors.push(vector);\r\n\t}\r\n\r\n\thasNormals(){\r\n\t\tfor (let name in this.attributes) {\r\n\t\t\tlet pointAttribute = this.attributes[name];\r\n\t\t\tif (\r\n\t\t\t\tpointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\r\n\t\t\t\tpointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\r\n\t\t\t\tpointAttribute === POINT_ATTRIBUTES.NORMAL ||\r\n\t\t\t\tpointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n}\r\n","\r\n\r\nimport {PointAttribute, PointAttributeTypes} from \"./PointAttributes\";\r\n\r\nconst typedArrayMapping = {\r\n\t\"int8\":   Int8Array,\r\n\t\"int16\":  Int16Array,\r\n\t\"int32\":  Int32Array,\r\n\t\"int64\":  Float64Array,\r\n\t\"uint8\":  Uint8Array,\r\n\t\"uint16\": Uint16Array,\r\n\t\"uint32\": Uint32Array,\r\n\t\"uint64\": Float64Array,\r\n\t\"float\":  Float32Array,\r\n\t\"double\": Float64Array,\r\n};\r\n\r\n// Potree = {};\r\n\r\nonmessage = function (event) {\r\n\r\n\tlet {buffer, pointAttributes, scale, name, min, max, size, offset, numPoints} = event.data;\r\n\r\n\tlet tStart = performance.now();\r\n\r\n\tlet view = new DataView(buffer);\r\n\t\r\n\tlet attributeBuffers = {};\r\n\tlet attributeOffset = 0;\r\n\r\n\tlet bytesPerPoint = 0;\r\n\tfor (let pointAttribute of pointAttributes.attributes) {\r\n\t\tbytesPerPoint += pointAttribute.byteSize;\r\n\t}\r\n\r\n\tlet gridSize = 32;\r\n\tlet grid = new Uint32Array(gridSize ** 3);\r\n\tlet toIndex = (x, y, z) => {\r\n\t\t// let dx = gridSize * (x - min.x) / size.x;\r\n\t\t// let dy = gridSize * (y - min.y) / size.y;\r\n\t\t// let dz = gridSize * (z - min.z) / size.z;\r\n\r\n\t\t// min is already subtracted\r\n\t\tlet dx = gridSize * x / size.x;\r\n\t\tlet dy = gridSize * y / size.y;\r\n\t\tlet dz = gridSize * z / size.z;\r\n\r\n\t\tlet ix = Math.min(parseInt(dx), gridSize - 1);\r\n\t\tlet iy = Math.min(parseInt(dy), gridSize - 1);\r\n\t\tlet iz = Math.min(parseInt(dz), gridSize - 1);\r\n\r\n\t\tlet index = ix + iy * gridSize + iz * gridSize * gridSize;\r\n\r\n\t\treturn index;\r\n\t};\r\n\r\n\tlet numOccupiedCells = 0;\r\n\tfor (let pointAttribute of pointAttributes.attributes) {\r\n\t\t\r\n\t\tif([\"POSITION_CARTESIAN\", \"position\"].includes(pointAttribute.name)){\r\n\t\t\tlet buff = new ArrayBuffer(numPoints * 4 * 3);\r\n\t\t\tlet positions = new Float32Array(buff);\r\n\t\t\r\n\t\t\tfor (let j = 0; j < numPoints; j++) {\r\n\t\t\t\t\r\n\t\t\t\tlet pointOffset = j * bytesPerPoint;\r\n\r\n\t\t\t\tlet x = (view.getInt32(pointOffset + attributeOffset + 0, true) * scale[0]) + offset[0] - min.x;\r\n\t\t\t\tlet y = (view.getInt32(pointOffset + attributeOffset + 4, true) * scale[1]) + offset[1] - min.y;\r\n\t\t\t\tlet z = (view.getInt32(pointOffset + attributeOffset + 8, true) * scale[2]) + offset[2] - min.z;\r\n\r\n\t\t\t\tlet index = toIndex(x, y, z);\r\n\t\t\t\tlet count = grid[index]++;\r\n\t\t\t\tif(count === 0){\r\n\t\t\t\t\tnumOccupiedCells++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpositions[3 * j + 0] = x;\r\n\t\t\t\tpositions[3 * j + 1] = y;\r\n\t\t\t\tpositions[3 * j + 2] = z;\r\n\t\t\t}\r\n\r\n\t\t\tattributeBuffers[pointAttribute.name] = { buffer: buff, attribute: pointAttribute };\r\n\t\t}else if([\"RGBA\", \"rgba\"].includes(pointAttribute.name)){\r\n\t\t\tlet buff = new ArrayBuffer(numPoints * 4);\r\n\t\t\tlet colors = new Uint8Array(buff);\r\n\r\n\t\t\tfor (let j = 0; j < numPoints; j++) {\r\n\t\t\t\tlet pointOffset = j * bytesPerPoint;\r\n\r\n\t\t\t\tlet r = view.getUint16(pointOffset + attributeOffset + 0, true);\r\n\t\t\t\tlet g = view.getUint16(pointOffset + attributeOffset + 2, true);\r\n\t\t\t\tlet b = view.getUint16(pointOffset + attributeOffset + 4, true);\r\n\r\n\t\t\t\tcolors[4 * j + 0] = r > 255 ? r / 256 : r;\r\n\t\t\t\tcolors[4 * j + 1] = g > 255 ? g / 256 : g;\r\n\t\t\t\tcolors[4 * j + 2] = b > 255 ? b / 256 : b;\r\n\t\t\t}\r\n\r\n\t\t\tattributeBuffers[pointAttribute.name] = { buffer: buff, attribute: pointAttribute };\r\n\t\t}else{\r\n\t\t\tlet buff = new ArrayBuffer(numPoints * 4);\r\n\t\t\tlet f32 = new Float32Array(buff);\r\n\r\n\t\t\tlet TypedArray = typedArrayMapping[pointAttribute.type.name];\r\n\t\t\tlet preciseBuffer = new TypedArray(numPoints);\r\n\r\n\t\t\tlet [offset, scale] = [0, 1];\r\n\r\n\t\t\tconst getterMap = {\r\n\t\t\t\t\"int8\":   view.getInt8,\r\n\t\t\t\t\"int16\":  view.getInt16,\r\n\t\t\t\t\"int32\":  view.getInt32,\r\n\t\t\t\t// \"int64\":  view.getInt64,\r\n\t\t\t\t\"uint8\":  view.getUint8,\r\n\t\t\t\t\"uint16\": view.getUint16,\r\n\t\t\t\t\"uint32\": view.getUint32,\r\n\t\t\t\t// \"uint64\": view.getUint64,\r\n\t\t\t\t\"float\":  view.getFloat32,\r\n\t\t\t\t\"double\": view.getFloat64,\r\n\t\t\t};\r\n\t\t\tconst getter = getterMap[pointAttribute.type.name].bind(view);\r\n\r\n\t\t\t// compute offset and scale to pack larger types into 32 bit floats\r\n\t\t\tif(pointAttribute.type.size > 4){\r\n\t\t\t\tlet [amin, amax] = pointAttribute.range;\r\n\t\t\t\toffset = amin;\r\n\t\t\t\tscale = 1 / (amax - amin);\r\n\t\t\t}\r\n\r\n\t\t\tfor(let j = 0; j < numPoints; j++){\r\n\t\t\t\tlet pointOffset = j * bytesPerPoint;\r\n\t\t\t\tlet value = getter(pointOffset + attributeOffset, true);\r\n\r\n\t\t\t\tf32[j] = (value - offset) * scale;\r\n\t\t\t\tpreciseBuffer[j] = value;\r\n\t\t\t}\r\n\r\n\t\t\tattributeBuffers[pointAttribute.name] = { \r\n\t\t\t\tbuffer: buff,\r\n\t\t\t\tpreciseBuffer: preciseBuffer,\r\n\t\t\t\tattribute: pointAttribute,\r\n\t\t\t\toffset: offset,\r\n\t\t\t\tscale: scale,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tattributeOffset += pointAttribute.byteSize;\r\n\r\n\r\n\t}\r\n\r\n\tlet occupancy = parseInt(numPoints / numOccupiedCells);\r\n\t// console.log(`${name}: #points: ${numPoints}: #occupiedCells: ${numOccupiedCells}, occupancy: ${occupancy} points/cell`);\r\n\r\n\t{ // add indices\r\n\t\tlet buff = new ArrayBuffer(numPoints * 4);\r\n\t\tlet indices = new Uint32Array(buff);\r\n\r\n\t\tfor (let i = 0; i < numPoints; i++) {\r\n\t\t\tindices[i] = i;\r\n\t\t}\r\n\t\t\r\n\t\tattributeBuffers[\"INDICES\"] = { buffer: buff, attribute: PointAttribute.INDICES };\r\n\t}\r\n\r\n\r\n\t{ // handle attribute vectors\r\n\t\tlet vectors = pointAttributes.vectors;\r\n\r\n\t\tfor(let vector of vectors){\r\n\r\n\t\t\tlet {name, attributes} = vector;\r\n\t\t\tlet numVectorElements = attributes.length;\r\n\t\t\tlet buffer = new ArrayBuffer(numVectorElements * numPoints * 4);\r\n\t\t\tlet f32 = new Float32Array(buffer);\r\n\r\n\t\t\tlet iElement = 0;\r\n\t\t\tfor(let sourceName of attributes){\r\n\t\t\t\tlet sourceBuffer = attributeBuffers[sourceName];\r\n\t\t\t\tlet {offset, scale} = sourceBuffer;\r\n\t\t\t\tlet view = new DataView(sourceBuffer.buffer);\r\n\r\n\t\t\t\tconst getter = view.getFloat32.bind(view);\r\n\r\n\t\t\t\tfor(let j = 0; j < numPoints; j++){\r\n\t\t\t\t\tlet value = getter(j * 4, true);\r\n\r\n\t\t\t\t\tf32[j * numVectorElements + iElement] = (value / scale) + offset;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tiElement++;\r\n\t\t\t}\r\n\r\n\t\t\tlet vecAttribute = new PointAttribute(name, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\r\n\r\n\t\t\tattributeBuffers[name] = { \r\n\t\t\t\tbuffer: buffer, \r\n\t\t\t\tattribute: vecAttribute,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// let duration = performance.now() - tStart;\r\n\t// let pointsPerMs = numPoints / duration;\r\n\t// console.log(`duration: ${duration.toFixed(1)}ms, #points: ${numPoints}, points/ms: ${pointsPerMs.toFixed(1)}`);\r\n\r\n\tlet message = {\r\n\t\tbuffer: buffer,\r\n\t\tattributeBuffers: attributeBuffers,\r\n\t\tdensity: occupancy,\r\n\t};\r\n\r\n\tlet transferables = [];\r\n\tfor (let property in message.attributeBuffers) {\r\n\t\ttransferables.push(message.attributeBuffers[property].buffer);\r\n\t}\r\n\ttransferables.push(buffer);\r\n\t// console.log(\"new\", message)\r\n\r\n\tpostMessage(message, transferables);\r\n};\r\n"],"names":["PointAttributeTypes","i","obj","PointAttribute","name","type","numElements","range","typedArrayMapping","event","buffer","pointAttributes","scale","min","max","size","offset","numPoints","view","attributeBuffers","attributeOffset","bytesPerPoint","pointAttribute","gridSize","grid","toIndex","x","y","z","dx","dy","dz","ix","iy","iz","numOccupiedCells","buff","positions","j","pointOffset","index","colors","r","g","b","f32","TypedArray","preciseBuffer","getter","amin","amax","value","occupancy","indices","vectors","vector","attributes","numVectorElements","iElement","sourceName","sourceBuffer","vecAttribute","message","transferables","property"],"mappings":"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"}