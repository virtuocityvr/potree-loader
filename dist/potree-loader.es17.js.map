{"version":3,"file":"potree-loader.es17.js","sources":["../src/point-cloud-octree-picker.ts"],"sourcesContent":["import {\r\n  BufferAttribute,\r\n  Camera,\r\n  LinearFilter,\r\n  NearestFilter,\r\n  NoBlending,\r\n  Points,\r\n  Ray,\r\n  RGBAFormat,\r\n  Scene,\r\n  Sphere,\r\n  Vector3,\r\n  Vector4,\r\n  WebGLRenderer,\r\n  WebGLRenderTarget,\r\n  Color,\r\n} from 'three';\r\nimport { COLOR_BLACK, DEFAULT_PICK_WINDOW_SIZE } from './constants';\r\nimport { ClipMode, PointCloudMaterial, PointColorType } from './materials';\r\nimport { PointCloudOctree } from './point-cloud-octree';\r\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\r\nimport { PickPoint, PointCloudHit } from './types';\r\nimport { clamp } from './utils/math';\r\n\r\nexport interface PickParams {\r\n  pickWindowSize: number;\r\n  pickOutsideClipRegion: boolean;\r\n  /**\r\n   * If provided, the picking will use this pixel position instead of the `Ray` passed to the `pick`\r\n   * method.\r\n   */\r\n  pixelPosition: Vector3;\r\n  /**\r\n   * Function which gets called after a picking material has been created and setup and before the\r\n   * point cloud is rendered into the picking render target. This gives applications a chance to\r\n   * customize the renderTarget and the material.\r\n   *\r\n   * @param material\r\n   *    The pick material.\r\n   * @param renterTarget\r\n   *    The render target used for picking.\r\n   */\r\n  onBeforePickRender: (material: PointCloudMaterial, renterTarget: WebGLRenderTarget) => void;\r\n}\r\n\r\ninterface IPickState {\r\n  renderTarget: WebGLRenderTarget;\r\n  material: PointCloudMaterial;\r\n  scene: Scene;\r\n}\r\n\r\ninterface RenderedNode {\r\n  node: PointCloudOctreeNode;\r\n  octree: PointCloudOctree;\r\n}\r\n\r\nexport class PointCloudOctreePicker {\r\n  private static readonly helperVec3 = new Vector3();\r\n  private static readonly helperSphere = new Sphere();\r\n  private static readonly clearColor = new Color();\r\n  private pickState: IPickState | undefined;\r\n\r\n  dispose() {\r\n    if (this.pickState) {\r\n      this.pickState.material.dispose();\r\n      this.pickState.renderTarget.dispose();\r\n    }\r\n  }\r\n\r\n  pick(\r\n    renderer: WebGLRenderer,\r\n    camera: Camera,\r\n    ray: Ray,\r\n    octrees: PointCloudOctree[],\r\n    params: Partial<PickParams> = {},\r\n  ): PickPoint | null {\r\n    if (octrees.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const pickState = this.pickState\r\n      ? this.pickState\r\n      : (this.pickState = PointCloudOctreePicker.getPickState());\r\n\r\n    const pickMaterial = pickState.material;\r\n\r\n    const pixelRatio = renderer.getPixelRatio();\r\n    const width = Math.ceil(renderer.domElement.clientWidth * pixelRatio);\r\n    const height = Math.ceil(renderer.domElement.clientHeight * pixelRatio);\r\n    PointCloudOctreePicker.updatePickRenderTarget(this.pickState, width, height);\r\n\r\n    const pixelPosition = PointCloudOctreePicker.helperVec3; // Use helper vector to prevent extra allocations.\r\n\r\n    if (params.pixelPosition) {\r\n      pixelPosition.copy(params.pixelPosition);\r\n    } else {\r\n      pixelPosition.addVectors(camera.position, ray.direction).project(camera);\r\n      pixelPosition.x = (pixelPosition.x + 1) * width * 0.5;\r\n      pixelPosition.y = (pixelPosition.y + 1) * height * 0.5;\r\n    }\r\n\r\n    const pickWndSize = Math.floor(\r\n      (params.pickWindowSize || DEFAULT_PICK_WINDOW_SIZE) * pixelRatio,\r\n    );\r\n    const halfPickWndSize = (pickWndSize - 1) / 2;\r\n    const x = Math.floor(clamp(pixelPosition.x - halfPickWndSize, 0, width));\r\n    const y = Math.floor(clamp(pixelPosition.y - halfPickWndSize, 0, height));\r\n\r\n    PointCloudOctreePicker.prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState);\r\n\r\n    const renderedNodes = PointCloudOctreePicker.render(\r\n      renderer,\r\n      camera,\r\n      pickMaterial,\r\n      octrees,\r\n      ray,\r\n      pickState,\r\n      params,\r\n    );\r\n\r\n    // Cleanup\r\n    pickMaterial.clearVisibleNodeTextureOffsets();\r\n\r\n    // Read back image and decode hit point\r\n    const pixels = PointCloudOctreePicker.readPixels(renderer, x, y, pickWndSize);\r\n    const hit = PointCloudOctreePicker.findHit(pixels, pickWndSize);\r\n    return PointCloudOctreePicker.getPickPoint(hit, renderedNodes);\r\n  }\r\n\r\n  private static prepareRender(\r\n    renderer: WebGLRenderer,\r\n    x: number,\r\n    y: number,\r\n    pickWndSize: number,\r\n    pickMaterial: PointCloudMaterial,\r\n    pickState: IPickState,\r\n  ) {\r\n    // Render the intersected nodes onto the pick render target, clipping to a small pick window.\r\n    renderer.setScissor(x, y, pickWndSize, pickWndSize);\r\n    renderer.setScissorTest(true);\r\n    renderer.state.buffers.depth.setTest(pickMaterial.depthTest);\r\n    renderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\r\n    renderer.state.setBlending(NoBlending);\r\n\r\n    renderer.setRenderTarget(pickState.renderTarget);\r\n\r\n    // Save the current clear color and clear the renderer with black color and alpha 0.\r\n    renderer.getClearColor(this.clearColor);\r\n    const oldClearAlpha = renderer.getClearAlpha();\r\n    renderer.setClearColor(COLOR_BLACK, 0);\r\n    renderer.clear(true, true, true);\r\n    renderer.setClearColor(this.clearColor, oldClearAlpha);\r\n  }\r\n\r\n  private static render(\r\n    renderer: WebGLRenderer,\r\n    camera: Camera,\r\n    pickMaterial: PointCloudMaterial,\r\n    octrees: PointCloudOctree[],\r\n    ray: Ray,\r\n    pickState: IPickState,\r\n    params: Partial<PickParams>,\r\n  ): RenderedNode[] {\r\n    const renderedNodes: RenderedNode[] = [];\r\n    for (const octree of octrees) {\r\n      // Get all the octree nodes which intersect the picking ray. We only need to render those.\r\n      const nodes = PointCloudOctreePicker.nodesOnRay(octree, ray);\r\n      if (!nodes.length) {\r\n        continue;\r\n      }\r\n\r\n      PointCloudOctreePicker.updatePickMaterial(pickMaterial, octree.material, params);\r\n      pickMaterial.updateMaterial(octree, nodes, camera, renderer);\r\n\r\n      if (params.onBeforePickRender) {\r\n        params.onBeforePickRender(pickMaterial, pickState.renderTarget);\r\n      }\r\n\r\n      // Create copies of the nodes so we can render them differently than in the normal point cloud.\r\n      pickState.scene.children = PointCloudOctreePicker.createTempNodes(\r\n        octree,\r\n        nodes,\r\n        pickMaterial,\r\n        renderedNodes.length,\r\n      );\r\n\r\n      renderer.render(pickState.scene, camera);\r\n\r\n      nodes.forEach(node => renderedNodes.push({ node, octree }));\r\n    }\r\n    return renderedNodes;\r\n  }\r\n\r\n  private static nodesOnRay(octree: PointCloudOctree, ray: Ray): PointCloudOctreeNode[] {\r\n    const nodesOnRay: PointCloudOctreeNode[] = [];\r\n\r\n    const rayClone = ray.clone();\r\n    for (const node of octree.visibleNodes) {\r\n      const sphere = PointCloudOctreePicker.helperSphere\r\n        .copy(node.boundingSphere)\r\n        .applyMatrix4(octree.matrixWorld);\r\n\r\n      if (rayClone.intersectsSphere(sphere)) {\r\n        nodesOnRay.push(node);\r\n      }\r\n    }\r\n\r\n    return nodesOnRay;\r\n  }\r\n\r\n  private static readPixels(\r\n    renderer: WebGLRenderer,\r\n    x: number,\r\n    y: number,\r\n    pickWndSize: number,\r\n  ): Uint8Array {\r\n    // Read the pixel from the pick render target.\r\n    const pixels = new Uint8Array(4 * pickWndSize * pickWndSize);\r\n    renderer.readRenderTargetPixels(\r\n      renderer.getRenderTarget()!,\r\n      x,\r\n      y,\r\n      pickWndSize,\r\n      pickWndSize,\r\n      pixels,\r\n    );\r\n    renderer.setScissorTest(false);\r\n    renderer.setRenderTarget(null!);\r\n    return pixels;\r\n  }\r\n\r\n  private static createTempNodes(\r\n    octree: PointCloudOctree,\r\n    nodes: PointCloudOctreeNode[],\r\n    pickMaterial: PointCloudMaterial,\r\n    nodeIndexOffset: number,\r\n  ): Points[] {\r\n    const tempNodes: Points[] = [];\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i];\r\n      const sceneNode = node.sceneNode;\r\n      const tempNode = new Points(sceneNode.geometry, pickMaterial);\r\n      tempNode.matrix = sceneNode.matrix;\r\n      tempNode.matrixWorld = sceneNode.matrixWorld;\r\n      tempNode.matrixAutoUpdate = false;\r\n      tempNode.frustumCulled = false;\r\n      const nodeIndex = nodeIndexOffset + i + 1;\r\n      if (nodeIndex > 255) {\r\n        console.error('More than 255 nodes for pick are not supported.');\r\n      }\r\n      tempNode.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(octree, node, nodeIndex);\r\n\r\n      tempNodes.push(tempNode);\r\n    }\r\n    return tempNodes;\r\n  }\r\n\r\n  private static updatePickMaterial(\r\n    pickMaterial: PointCloudMaterial,\r\n    nodeMaterial: PointCloudMaterial,\r\n    params: Partial<PickParams>,\r\n  ): void {\r\n    pickMaterial.pointSizeType = nodeMaterial.pointSizeType;\r\n    pickMaterial.shape = nodeMaterial.shape;\r\n    pickMaterial.size = nodeMaterial.size;\r\n    pickMaterial.minSize = nodeMaterial.minSize;\r\n    pickMaterial.maxSize = nodeMaterial.maxSize;\r\n    pickMaterial.classification = nodeMaterial.classification;\r\n    pickMaterial.useFilterByNormal = nodeMaterial.useFilterByNormal;\r\n    pickMaterial.filterByNormalThreshold = nodeMaterial.filterByNormalThreshold;\r\n\r\n    if (params.pickOutsideClipRegion) {\r\n      pickMaterial.clipMode = ClipMode.DISABLED;\r\n    } else {\r\n      pickMaterial.clipMode = nodeMaterial.clipMode;\r\n      pickMaterial.setClipBoxes(\r\n        nodeMaterial.clipMode === ClipMode.CLIP_OUTSIDE ? nodeMaterial.clipBoxes : [],\r\n      );\r\n    }\r\n  }\r\n\r\n  private static updatePickRenderTarget(\r\n    pickState: IPickState,\r\n    width: number,\r\n    height: number,\r\n  ): void {\r\n    if (pickState.renderTarget.width === width && pickState.renderTarget.height === height) {\r\n      return;\r\n    }\r\n\r\n    pickState.renderTarget.dispose();\r\n    pickState.renderTarget = PointCloudOctreePicker.makePickRenderTarget();\r\n    pickState.renderTarget.setSize(width, height);\r\n  }\r\n\r\n  private static makePickRenderTarget() {\r\n    return new WebGLRenderTarget(1, 1, {\r\n      minFilter: LinearFilter,\r\n      magFilter: NearestFilter,\r\n      format: RGBAFormat,\r\n    });\r\n  }\r\n\r\n  private static findHit(pixels: Uint8Array, pickWndSize: number): PointCloudHit | null {\r\n    const ibuffer = new Uint32Array(pixels.buffer);\r\n\r\n    // Find closest hit inside pixelWindow boundaries\r\n    let min = Number.MAX_VALUE;\r\n    let hit: PointCloudHit | null = null;\r\n    for (let u = 0; u < pickWndSize; u++) {\r\n      for (let v = 0; v < pickWndSize; v++) {\r\n        const offset = u + v * pickWndSize;\r\n        const distance =\r\n          Math.pow(u - (pickWndSize - 1) / 2, 2) + Math.pow(v - (pickWndSize - 1) / 2, 2);\r\n\r\n        const pcIndex = pixels[4 * offset + 3];\r\n        pixels[4 * offset + 3] = 0;\r\n        const pIndex = ibuffer[offset];\r\n\r\n        if (pcIndex > 0 && distance < min) {\r\n          hit = {\r\n            pIndex: pIndex,\r\n            pcIndex: pcIndex - 1,\r\n          };\r\n          min = distance;\r\n        }\r\n      }\r\n    }\r\n    return hit;\r\n  }\r\n\r\n  private static getPickPoint(hit: PointCloudHit | null, nodes: RenderedNode[]): PickPoint | null {\r\n    if (!hit) {\r\n      return null;\r\n    }\r\n\r\n    const point: PickPoint = {};\r\n\r\n    const points = nodes[hit.pcIndex] && nodes[hit.pcIndex].node.sceneNode;\r\n    if (!points) {\r\n      return null;\r\n    }\r\n\r\n    point.pointCloud = nodes[hit.pcIndex].octree;\r\n\r\n    const attributes: BufferAttribute[] = (points.geometry as any).attributes;\r\n\r\n    for (const property in attributes) {\r\n      if (!attributes.hasOwnProperty(property)) {\r\n        continue;\r\n      }\r\n\r\n      const values = attributes[property];\r\n\r\n      // tslint:disable-next-line:prefer-switch\r\n      if (property === 'position') {\r\n        PointCloudOctreePicker.addPositionToPickPoint(point, hit, values, points);\r\n      } else if (property === 'normal') {\r\n        PointCloudOctreePicker.addNormalToPickPoint(point, hit, values, points);\r\n      } else if (property === 'indices') {\r\n        // TODO\r\n      } else {\r\n        if (values.itemSize === 1) {\r\n          point[property] = values.array[hit.pIndex];\r\n        } else {\r\n          const value: number[] = [];\r\n          for (let j = 0; j < values.itemSize; j++) {\r\n            value.push(values.array[values.itemSize * hit.pIndex + j]);\r\n          }\r\n          point[property] = value;\r\n        }\r\n      }\r\n    }\r\n\r\n    return point;\r\n  }\r\n\r\n  private static addPositionToPickPoint(\r\n    point: PickPoint,\r\n    hit: PointCloudHit,\r\n    values: BufferAttribute,\r\n    points: Points,\r\n  ): void {\r\n    point.position = new Vector3()\r\n      .fromBufferAttribute(values, hit.pIndex)\r\n      .applyMatrix4(points.matrixWorld);\r\n  }\r\n\r\n  private static addNormalToPickPoint(\r\n    point: PickPoint,\r\n    hit: PointCloudHit,\r\n    values: BufferAttribute,\r\n    points: Points,\r\n  ): void {\r\n    const normal = new Vector3().fromBufferAttribute(values, hit.pIndex);\r\n    const normal4 = new Vector4(normal.x, normal.y, normal.z, 0).applyMatrix4(points.matrixWorld);\r\n    normal.set(normal4.x, normal4.y, normal4.z);\r\n\r\n    point.normal = normal;\r\n  }\r\n\r\n  private static getPickState() {\r\n    const scene = new Scene();\r\n    scene.autoUpdate = false;\r\n\r\n    const material = new PointCloudMaterial();\r\n    material.pointColorType = PointColorType.POINT_INDEX;\r\n\r\n    return {\r\n      renderTarget: PointCloudOctreePicker.makePickRenderTarget(),\r\n      material: material,\r\n      scene: scene,\r\n    };\r\n  }\r\n}\r\n"],"names":["_PointCloudOctreePicker","renderer","camera","ray","octrees","params","pickState","pickMaterial","pixelRatio","width","height","pixelPosition","pickWndSize","DEFAULT_PICK_WINDOW_SIZE","halfPickWndSize","x","clamp","y","renderedNodes","pixels","hit","NoBlending","oldClearAlpha","COLOR_BLACK","octree","nodes","node","nodesOnRay","rayClone","sphere","nodeIndexOffset","tempNodes","sceneNode","tempNode","Points","nodeIndex","PointCloudMaterial","nodeMaterial","ClipMode","WebGLRenderTarget","LinearFilter","NearestFilter","RGBAFormat","ibuffer","min","u","v","offset","distance","pcIndex","pIndex","point","points","attributes","property","values","value","j","Vector3","normal","normal4","Vector4","scene","Scene","material","PointColorType","PointCloudOctreePicker","Sphere","Color"],"mappings":"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"}