{"version":3,"file":"potree-loader.es2.js","sources":["../src/point-cloud-octree.ts"],"sourcesContent":["import { OctreeGeometry } from './loading2/OctreeGeometry';\r\nimport { Box3, Camera, Object3D, Points, Ray, Sphere, Vector3, WebGLRenderer } from 'three';\r\nimport { DEFAULT_MIN_NODE_PIXEL_SIZE } from './constants';\r\nimport { PointCloudMaterial, PointSizeType } from './materials';\r\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\r\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\r\nimport { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';\r\nimport { PointCloudTree } from './point-cloud-tree';\r\nimport { IPointCloudTreeNode, IPotree, PickPoint, PCOGeometry } from './types';\r\nimport { computeTransformedBoundingBox } from './utils/bounds';\r\n\r\nexport class PointCloudOctree extends PointCloudTree {\r\n  potree: IPotree;\r\n  disposed: boolean = false;\r\n  pcoGeometry: PCOGeometry;\r\n  boundingBox: Box3;\r\n  boundingSphere: Sphere;\r\n  material: PointCloudMaterial;\r\n  level: number = 0;\r\n  maxLevel: number = Infinity;\r\n  /**\r\n   * The minimum radius of a node's bounding sphere on the screen in order to be displayed.\r\n   */\r\n  minNodePixelSize: number = DEFAULT_MIN_NODE_PIXEL_SIZE;\r\n  root: IPointCloudTreeNode | null = null;\r\n  boundingBoxNodes: Object3D[] = [];\r\n  visibleNodes: PointCloudOctreeNode[] = [];\r\n  visibleGeometry: PointCloudOctreeGeometryNode[] = [];\r\n  numVisiblePoints: number = 0;\r\n  showBoundingBox: boolean = false;\r\n  private visibleBounds: Box3 = new Box3();\r\n  private picker: PointCloudOctreePicker | undefined;\r\n\r\n  constructor(\r\n    potree: IPotree,\r\n    pcoGeometry: PCOGeometry,\r\n    material?: PointCloudMaterial,\r\n  ) {\r\n    super();\r\n\r\n    this.name = '';\r\n    this.potree = potree;\r\n    this.root = pcoGeometry.root;\r\n    this.pcoGeometry = pcoGeometry;\r\n    this.boundingBox = pcoGeometry.boundingBox;\r\n    this.boundingSphere = this.boundingBox.getBoundingSphere(new Sphere());\r\n\r\n    this.position.copy(pcoGeometry.offset);\r\n    this.updateMatrix();\r\n\r\n    this.material = material || (pcoGeometry instanceof OctreeGeometry) ? new PointCloudMaterial({newFormat: true}) : new PointCloudMaterial();\r\n    this.initMaterial(this.material);\r\n  }\r\n\r\n  private initMaterial(material: PointCloudMaterial): void {\r\n    this.updateMatrixWorld(true);\r\n\r\n    const { min, max } = computeTransformedBoundingBox(\r\n      this.pcoGeometry.tightBoundingBox || this.getBoundingBoxWorld(),\r\n      this.matrixWorld,\r\n    );\r\n\r\n    const bWidth = max.z - min.z;\r\n    material.heightMin = min.z - 0.2 * bWidth;\r\n    material.heightMax = max.z + 0.2 * bWidth;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.root) {\r\n      this.root.dispose();\r\n    }\r\n\r\n    this.pcoGeometry.root.traverse((n:IPointCloudTreeNode) => this.potree.lru.remove(n));\r\n    this.pcoGeometry.dispose();\r\n    this.material.dispose();\r\n\r\n    this.visibleNodes = [];\r\n    this.visibleGeometry = [];\r\n\r\n    if (this.picker) {\r\n      this.picker.dispose();\r\n      this.picker = undefined;\r\n    }\r\n\r\n    this.disposed = true;\r\n  }\r\n\r\n  get pointSizeType(): PointSizeType {\r\n    return this.material.pointSizeType;\r\n  }\r\n\r\n  set pointSizeType(value: PointSizeType) {\r\n    this.material.pointSizeType = value;\r\n  }\r\n\r\n  toTreeNode(\r\n    geometryNode: PointCloudOctreeGeometryNode,\r\n    parent?: PointCloudOctreeNode | null,\r\n  ): PointCloudOctreeNode {\r\n    const points = new Points(geometryNode.geometry, this.material);\r\n    const node = new PointCloudOctreeNode(geometryNode, points);\r\n    points.name = geometryNode.name;\r\n    points.position.copy(geometryNode.boundingBox.min);\r\n    points.frustumCulled = false;\r\n    points.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(this, node);\r\n\r\n    if (parent) {\r\n      parent.sceneNode.add(points);\r\n      parent.children[geometryNode.index] = node;\r\n\r\n      geometryNode.oneTimeDisposeHandlers.push(() => {\r\n        node.disposeSceneNode();\r\n        parent.sceneNode.remove(node.sceneNode);\r\n        // Replace the tree node (rendered and in the GPU) with the geometry node.\r\n        parent.children[geometryNode.index] = geometryNode;\r\n      });\r\n    } else {\r\n      this.root = node;\r\n      this.add(points);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  updateVisibleBounds() {\r\n    const bounds = this.visibleBounds;\r\n    bounds.min.set(Infinity, Infinity, Infinity);\r\n    bounds.max.set(-Infinity, -Infinity, -Infinity);\r\n\r\n    for (const node of this.visibleNodes) {\r\n      if (node.isLeafNode) {\r\n        bounds.expandByPoint(node.boundingBox.min);\r\n        bounds.expandByPoint(node.boundingBox.max);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateBoundingBoxes(): void {\r\n    if (!this.showBoundingBox || !this.parent) {\r\n      return;\r\n    }\r\n    // Above: If we're not showing the bounding box or we don't have a parent, we can't update it.\r\n\r\n    let bbRoot: any = this.parent.getObjectByName('bbroot');\r\n    if (!bbRoot) {\r\n      bbRoot = new Object3D();\r\n      bbRoot.name = 'bbroot';\r\n      this.parent.add(bbRoot);\r\n    }\r\n    // Above: If we don't have a root object, we need to create one.\r\n\r\n    const visibleBoxes: (Object3D | null)[] = [];\r\n    for (const node of this.visibleNodes) {\r\n      if (node.boundingBoxNode !== undefined && node.isLeafNode) {\r\n        visibleBoxes.push(node.boundingBoxNode);\r\n      }\r\n    }\r\n\r\n    bbRoot.children = visibleBoxes;\r\n  }\r\n\r\n  updateMatrixWorld(force: boolean): void {\r\n    if (this.matrixAutoUpdate === true) {\r\n      this.updateMatrix();\r\n    }\r\n\r\n    if (this.matrixWorldNeedsUpdate === true || force === true) {\r\n      if (!this.parent) {\r\n        this.matrixWorld.copy(this.matrix);\r\n      } else {\r\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\r\n      }\r\n\r\n      this.matrixWorldNeedsUpdate = false;\r\n\r\n      force = true;\r\n    }\r\n  }\r\n\r\n  hideDescendants(object: Object3D): void {\r\n    const toHide: Object3D[] = [];\r\n    addVisibleChildren(object);\r\n\r\n    while (toHide.length > 0) {\r\n      const objToHide = toHide.shift()!;\r\n      objToHide.visible = false;\r\n      addVisibleChildren(objToHide);\r\n    }\r\n\r\n    function addVisibleChildren(obj: Object3D) {\r\n      for (const child of obj.children) {\r\n        if (child.visible) {\r\n          toHide.push(child);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  moveToOrigin(): void {\r\n    this.position.set(0, 0, 0); // Reset, then the matrix will be updated in getBoundingBoxWorld()\r\n    this.position.set(0, 0, 0).sub(this.getBoundingBoxWorld().getCenter(new Vector3()));\r\n  }\r\n\r\n  moveToGroundPlane(): void {\r\n    this.position.y += -this.getBoundingBoxWorld().min.y;\r\n  }\r\n\r\n  getBoundingBoxWorld(): Box3 {\r\n    this.updateMatrixWorld(true);\r\n    return computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);\r\n  }\r\n\r\n  getVisibleExtent() {\r\n    return this.visibleBounds.applyMatrix4(this.matrixWorld);\r\n  }\r\n\r\n  pick(\r\n    renderer: WebGLRenderer,\r\n    camera: Camera,\r\n    ray: Ray,\r\n    params: Partial<PickParams> = {},\r\n  ): PickPoint | null {\r\n    this.picker = this.picker || new PointCloudOctreePicker();\r\n    return this.picker.pick(renderer, camera, ray, [this], params);\r\n  }\r\n\r\n  get progress() {\r\n    return this.visibleGeometry.length === 0\r\n      ? 0\r\n      : this.visibleNodes.length / this.visibleGeometry.length;\r\n  }\r\n}\r\n"],"names":["PointCloudOctree","PointCloudTree","potree","pcoGeometry","material","DEFAULT_MIN_NODE_PIXEL_SIZE","Box3","Sphere","OctreeGeometry","PointCloudMaterial","min","max","computeTransformedBoundingBox","bWidth","n","value","geometryNode","parent","points","Points","node","PointCloudOctreeNode","bounds","bbRoot","Object3D","visibleBoxes","force","object","toHide","addVisibleChildren","objToHide","obj","child","Vector3","renderer","camera","ray","params","PointCloudOctreePicker"],"mappings":"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"}