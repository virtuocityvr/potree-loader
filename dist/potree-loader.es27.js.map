{"version":3,"file":"potree-loader.es27.js","sources":["../src/utils/binary-heap.js"],"sourcesContent":["/**\r\n * from: http://eloquentjavascript.net/1st_edition/appendix2.html\r\n *\r\n */\r\n\r\nexport function BinaryHeap(scoreFunction) {\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n    // Allow it to bubble up.\r\n    this.bubbleUp(this.content.length - 1);\r\n  },\r\n\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it sink down.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.sinkDown(0);\r\n    }\r\n    return result;\r\n  },\r\n\r\n  remove: function(node) {\r\n    var length = this.content.length;\r\n    // To remove a value, we must search through the array to find\r\n    // it.\r\n    for (var i = 0; i < length; i++) {\r\n      if (this.content[i] != node) continue;\r\n      // When it is found, the process seen in 'pop' is repeated\r\n      // to fill up the hole.\r\n      var end = this.content.pop();\r\n      // If the element we popped was the one we needed to remove,\r\n      // we're done.\r\n      if (i == length - 1) break;\r\n      // Otherwise, we replace the removed element with the popped\r\n      // one, and allow it to float up or sink down as appropriate.\r\n      this.content[i] = end;\r\n      this.bubbleUp(i);\r\n      this.sinkDown(i);\r\n      break;\r\n    }\r\n  },\r\n\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n\r\n  bubbleUp: function(n) {\r\n    // Fetch the element that has to be moved.\r\n    var element = this.content[n],\r\n      score = this.scoreFunction(element);\r\n    // When at 0, an element can not go up any further.\r\n    while (n > 0) {\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = Math.floor((n + 1) / 2) - 1,\r\n        parent = this.content[parentN];\r\n      // If the parent has a lesser score, things are in order and we\r\n      // are done.\r\n      if (score >= this.scoreFunction(parent)) break;\r\n\r\n      // Otherwise, swap the parent with the current element and\r\n      // continue.\r\n      this.content[parentN] = element;\r\n      this.content[n] = parent;\r\n      n = parentN;\r\n    }\r\n  },\r\n\r\n  sinkDown: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length,\r\n      element = this.content[n],\r\n      elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) * 2,\r\n        child1N = child2N - 1;\r\n      // This is used to store the new position of the element,\r\n      // if any.\r\n      var swap = null;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N],\r\n          child1Score = this.scoreFunction(child1);\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) swap = child1N;\r\n      }\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N],\r\n          child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\r\n      }\r\n\r\n      // No need to swap further, we are done.\r\n      if (swap == null) break;\r\n\r\n      // Otherwise, swap and continue.\r\n      this.content[n] = this.content[swap];\r\n      this.content[swap] = element;\r\n      n = swap;\r\n    }\r\n  },\r\n};\r\n"],"names":["BinaryHeap","scoreFunction","element","result","end","node","length","i","n","score","parentN","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","child2Score"],"mappings":"AAKO,SAASA,EAAWC,GAAe;AACxC,OAAK,UAAU,IACf,KAAK,gBAAgBA;AACvB;AAEAD,EAAW,YAAY;AAAA,EACrB,MAAM,SAASE,GAAS;AAEtB,SAAK,QAAQ,KAAKA,CAAO,GAEzB,KAAK,SAAS,KAAK,QAAQ,SAAS,CAAC;AAAA,EACtC;AAAA,EAED,KAAK,WAAW;AAEd,QAAIC,IAAS,KAAK,QAAQ,CAAC,GAEvBC,IAAM,KAAK,QAAQ,IAAG;AAG1B,WAAI,KAAK,QAAQ,SAAS,MACxB,KAAK,QAAQ,CAAC,IAAIA,GAClB,KAAK,SAAS,CAAC,IAEVD;AAAA,EACR;AAAA,EAED,QAAQ,SAASE,GAAM;AAIrB,aAHIC,IAAS,KAAK,QAAQ,QAGjBC,IAAI,GAAGA,IAAID,GAAQC;AAC1B,UAAI,KAAK,QAAQA,CAAC,KAAKF,GAGvB;AAAA,YAAID,IAAM,KAAK,QAAQ,IAAG;AAG1B,YAAIG,KAAKD,IAAS;AAAG;AAGrB,aAAK,QAAQC,CAAC,IAAIH,GAClB,KAAK,SAASG,CAAC,GACf,KAAK,SAASA,CAAC;AACf;AAAA;AAAA,EAEH;AAAA,EAED,MAAM,WAAW;AACf,WAAO,KAAK,QAAQ;AAAA,EACrB;AAAA,EAED,UAAU,SAASC,GAAG;AAKpB,aAHIN,IAAU,KAAK,QAAQM,CAAC,GAC1BC,IAAQ,KAAK,cAAcP,CAAO,GAE7BM,IAAI,KAAG;AAEZ,UAAIE,IAAU,KAAK,OAAOF,IAAI,KAAK,CAAC,IAAI,GACtCG,IAAS,KAAK,QAAQD,CAAO;AAG/B,UAAID,KAAS,KAAK,cAAcE,CAAM;AAAG;AAIzC,WAAK,QAAQD,CAAO,IAAIR,GACxB,KAAK,QAAQM,CAAC,IAAIG,GAClBH,IAAIE;AAAA;AAAA,EAEP;AAAA,EAED,UAAU,SAASF,GAAG;AAMpB,aAJIF,IAAS,KAAK,QAAQ,QACxBJ,IAAU,KAAK,QAAQM,CAAC,GACxBI,IAAY,KAAK,cAAcV,CAAO,OAE3B;AAEX,UAAIW,KAAWL,IAAI,KAAK,GACtBM,IAAUD,IAAU,GAGlBE,IAAO;AAEX,UAAID,IAAUR,GAAQ;AAEpB,YAAIU,IAAS,KAAK,QAAQF,CAAO,GAC/BG,IAAc,KAAK,cAAcD,CAAM;AAEzC,QAAIC,IAAcL,MAAWG,IAAOD;AAAA;AAGtC,UAAID,IAAUP,GAAQ;AACpB,YAAIY,IAAS,KAAK,QAAQL,CAAO,GAC/BM,IAAc,KAAK,cAAcD,CAAM;AACzC,QAAIC,KAAeJ,KAAQ,OAAOH,IAAYK,OAAcF,IAAOF;AAAA;AAIrE,UAAIE,KAAQ;AAAM;AAGlB,WAAK,QAAQP,CAAC,IAAI,KAAK,QAAQO,CAAI,GACnC,KAAK,QAAQA,CAAI,IAAIb,GACrBM,IAAIO;AAAA;AAAA,EAEP;AACH;"}