{"version":3,"file":"potree-loader.es3.js","sources":["../src/potree.ts"],"sourcesContent":["import { OctreeGeometry } from './loading2/OctreeGeometry';\r\nimport { loadOctree } from './loading2/load-octree';\r\nimport {\r\n  Box3,\r\n  Camera,\r\n  Frustum,\r\n  Matrix4,\r\n  OrthographicCamera,\r\n  PerspectiveCamera,\r\n  Ray,\r\n  Vector2,\r\n  Vector3,\r\n  WebGLRenderer,\r\n} from 'three';\r\nimport {\r\n  DEFAULT_POINT_BUDGET,\r\n  MAX_LOADS_TO_GPU,\r\n  MAX_NUM_NODES_LOADING,\r\n  PERSPECTIVE_CAMERA,\r\n} from './constants';\r\nimport { FEATURES } from './features';\r\nimport { GetUrlFn, loadPOC } from './loading';\r\nimport { ClipMode } from './materials';\r\nimport { PointCloudOctree } from './point-cloud-octree';\r\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\r\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\r\nimport { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';\r\nimport { isGeometryNode, isTreeNode } from './type-predicates';\r\nimport { IPointCloudTreeNode, IPotree, IVisibilityUpdateResult, PickPoint } from './types';\r\nimport { BinaryHeap } from './utils/binary-heap';\r\nimport { Box3Helper } from './utils/box3-helper';\r\nimport { LRU } from './utils/lru';\r\n\r\n\r\nexport class QueueItem {\r\n  constructor(\r\n    public pointCloudIndex: number,\r\n    public weight: number,\r\n    public node: IPointCloudTreeNode,\r\n    public parent?: IPointCloudTreeNode | null,\r\n  ) {}\r\n}\r\n\r\nexport class Potree implements IPotree {\r\n  private static picker: PointCloudOctreePicker | undefined;\r\n  private _pointBudget: number = DEFAULT_POINT_BUDGET;\r\n  private _rendererSize: Vector2 = new Vector2();\r\n\r\n  maxNumNodesLoading: number = MAX_NUM_NODES_LOADING;\r\n  features = FEATURES;\r\n  lru = new LRU(this._pointBudget);\r\n\r\n  async loadPointCloud(\r\n    url: string,\r\n    getUrl: GetUrlFn,\r\n    xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),\r\n  ): Promise<PointCloudOctree> {\r\n    if (url === \"cloud.js\") {\r\n      return await loadPOC(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));\r\n    } else if (url === \"metadata.json\") {\r\n      // throw new Error(\"Not implemented\")\r\n      return await loadOctree(url, getUrl, xhrRequest).then((geometry:OctreeGeometry) => new PointCloudOctree(this, geometry));\r\n    }\r\n    throw new Error(\"Unsupported file type\");\r\n  }\r\n\r\n  updatePointClouds(\r\n    pointClouds: PointCloudOctree[],\r\n    camera: Camera,\r\n    renderer: WebGLRenderer,\r\n  ): IVisibilityUpdateResult {\r\n    const result = this.updateVisibility(pointClouds, camera, renderer);\r\n\r\n    for (let i = 0; i < pointClouds.length; i++) {\r\n      const pointCloud = pointClouds[i];\r\n      if (pointCloud.disposed) {\r\n        continue;\r\n      }\r\n\r\n      pointCloud.material.updateMaterial(pointCloud, pointCloud.visibleNodes, camera, renderer);\r\n      pointCloud.updateVisibleBounds();\r\n      pointCloud.updateBoundingBoxes();\r\n    }\r\n\r\n    this.lru.freeMemory();\r\n\r\n    return result;\r\n  }\r\n\r\n  static pick(\r\n    pointClouds: PointCloudOctree[],\r\n    renderer: WebGLRenderer,\r\n    camera: Camera,\r\n    ray: Ray,\r\n    params: Partial<PickParams> = {},\r\n  ): PickPoint | null {\r\n    Potree.picker = Potree.picker || new PointCloudOctreePicker();\r\n    return Potree.picker.pick(renderer, camera, ray, pointClouds, params);\r\n  }\r\n\r\n  get pointBudget(): number {\r\n    return this._pointBudget;\r\n  }\r\n\r\n  set pointBudget(value: number) {\r\n    if (value !== this._pointBudget) {\r\n      this._pointBudget = value;\r\n      this.lru.pointBudget = value;\r\n      this.lru.freeMemory();\r\n    }\r\n  }\r\n\r\n  private updateVisibility(\r\n    pointClouds: PointCloudOctree[],\r\n    camera: Camera,\r\n    renderer: WebGLRenderer,\r\n  ): IVisibilityUpdateResult {\r\n    let numVisiblePoints = 0;\r\n\r\n    const visibleNodes: PointCloudOctreeNode[] = [];\r\n    const unloadedGeometry: PointCloudOctreeGeometryNode[] = [];\r\n\r\n    // calculate object space frustum and cam pos and setup priority queue\r\n    const { frustums, cameraPositions, priorityQueue } = this.updateVisibilityStructures(\r\n      pointClouds,\r\n      camera,\r\n    );\r\n\r\n    let loadedToGPUThisFrame = 0;\r\n    let exceededMaxLoadsToGPU = false;\r\n    let nodeLoadFailed = false;\r\n    let queueItem: QueueItem | undefined;\r\n\r\n    while ((queueItem = priorityQueue.pop()) !== undefined) {\r\n      let node = queueItem.node;\r\n\r\n      // If we will end up with too many points, we stop right away.\r\n      if (numVisiblePoints + node.numPoints > this.pointBudget) {\r\n        break;\r\n      }\r\n\r\n      const pointCloudIndex = queueItem.pointCloudIndex;\r\n      const pointCloud = pointClouds[pointCloudIndex];\r\n\r\n      const maxLevel = pointCloud.maxLevel !== undefined ? pointCloud.maxLevel : Infinity;\r\n\r\n      if (\r\n        node.level > maxLevel ||\r\n        !frustums[pointCloudIndex].intersectsBox(node.boundingBox) ||\r\n        this.shouldClip(pointCloud, node.boundingBox)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      numVisiblePoints += node.numPoints;\r\n      pointCloud.numVisiblePoints += node.numPoints;\r\n\r\n      const parentNode = queueItem.parent;\r\n\r\n      if (isGeometryNode(node) && (!parentNode || isTreeNode(parentNode))) {\r\n        if (node.loaded && loadedToGPUThisFrame < MAX_LOADS_TO_GPU) {\r\n          node = pointCloud.toTreeNode(node, parentNode);\r\n          loadedToGPUThisFrame++;\r\n        } else if (!node.failed) {\r\n          if (node.loaded && loadedToGPUThisFrame >= MAX_LOADS_TO_GPU) {\r\n            exceededMaxLoadsToGPU = true;\r\n          }\r\n          unloadedGeometry.push(node);\r\n          pointCloud.visibleGeometry.push(node);\r\n        } else {\r\n          nodeLoadFailed = true;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if (isTreeNode(node)) {\r\n        this.updateTreeNodeVisibility(pointCloud, node, visibleNodes);\r\n        pointCloud.visibleGeometry.push(node.geometryNode);\r\n      }\r\n\r\n      const halfHeight =\r\n        0.5 * renderer.getSize(this._rendererSize).height * renderer.getPixelRatio();\r\n\r\n      this.updateChildVisibility(\r\n        queueItem,\r\n        priorityQueue,\r\n        pointCloud,\r\n        node,\r\n        cameraPositions[pointCloudIndex],\r\n        camera,\r\n        halfHeight,\r\n      );\r\n    } // end priority queue loop\r\n\r\n    const numNodesToLoad = Math.min(this.maxNumNodesLoading, unloadedGeometry.length);\r\n    const nodeLoadPromises: Promise<void>[] = [];\r\n    for (let i = 0; i < numNodesToLoad; i++) {\r\n      nodeLoadPromises.push(unloadedGeometry[i].load());\r\n    }\r\n\r\n    return {\r\n      visibleNodes: visibleNodes,\r\n      numVisiblePoints: numVisiblePoints,\r\n      exceededMaxLoadsToGPU: exceededMaxLoadsToGPU,\r\n      nodeLoadFailed: nodeLoadFailed,\r\n      nodeLoadPromises: nodeLoadPromises,\r\n    };\r\n  }\r\n\r\n  private updateTreeNodeVisibility(\r\n    pointCloud: PointCloudOctree,\r\n    node: PointCloudOctreeNode,\r\n    visibleNodes: IPointCloudTreeNode[],\r\n  ): void {\r\n    this.lru.touch(node.geometryNode);\r\n\r\n    const sceneNode = node.sceneNode;\r\n    sceneNode.visible = true;\r\n    sceneNode.material = pointCloud.material;\r\n    sceneNode.updateMatrix();\r\n    sceneNode.matrixWorld.multiplyMatrices(pointCloud.matrixWorld, sceneNode.matrix);\r\n\r\n    visibleNodes.push(node);\r\n    pointCloud.visibleNodes.push(node);\r\n\r\n    this.updateBoundingBoxVisibility(pointCloud, node);\r\n  }\r\n\r\n  private updateChildVisibility(\r\n    queueItem: QueueItem,\r\n    priorityQueue: BinaryHeap<QueueItem>,\r\n    pointCloud: PointCloudOctree,\r\n    node: IPointCloudTreeNode,\r\n    cameraPosition: Vector3,\r\n    camera: Camera,\r\n    halfHeight: number,\r\n  ): void {\r\n    const children = node.children;\r\n    for (let i = 0; i < children.length; i++) {\r\n      const child = children[i];\r\n      if (child === null) {\r\n        continue;\r\n      }\r\n\r\n      const sphere = child.boundingSphere;\r\n      const distance = sphere.center.distanceTo(cameraPosition);\r\n      const radius = sphere.radius;\r\n\r\n      let projectionFactor = 0.0;\r\n\r\n      if (camera.type === PERSPECTIVE_CAMERA) {\r\n        const perspective = camera as PerspectiveCamera;\r\n        const fov = (perspective.fov * Math.PI) / 180.0;\r\n        const slope = Math.tan(fov / 2.0);\r\n        projectionFactor = halfHeight / (slope * distance);\r\n      } else {\r\n        const orthographic = camera as OrthographicCamera;\r\n        projectionFactor = (2 * halfHeight) / (orthographic.top - orthographic.bottom);\r\n      }\r\n\r\n      const screenPixelRadius = radius * projectionFactor;\r\n\r\n      // Don't add the node if it'll be too small on the screen.\r\n      if (screenPixelRadius < pointCloud.minNodePixelSize) {\r\n        continue;\r\n      }\r\n\r\n      // Nodes which are larger will have priority in loading/displaying.\r\n      const weight = distance < radius ? Number.MAX_VALUE : screenPixelRadius + 1 / distance;\r\n\r\n      priorityQueue.push(new QueueItem(queueItem.pointCloudIndex, weight, child, node));\r\n    }\r\n  }\r\n\r\n  private updateBoundingBoxVisibility(\r\n    pointCloud: PointCloudOctree,\r\n    node: PointCloudOctreeNode,\r\n  ): void {\r\n    if (pointCloud.showBoundingBox && !node.boundingBoxNode) {\r\n      const boxHelper = new Box3Helper(node.boundingBox);\r\n      boxHelper.matrixAutoUpdate = false;\r\n      pointCloud.boundingBoxNodes.push(boxHelper);\r\n      node.boundingBoxNode = boxHelper;\r\n      node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\r\n    } else if (pointCloud.showBoundingBox && node.boundingBoxNode) {\r\n      node.boundingBoxNode.visible = true;\r\n      node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\r\n    } else if (!pointCloud.showBoundingBox && node.boundingBoxNode) {\r\n      node.boundingBoxNode.visible = false;\r\n    }\r\n  }\r\n\r\n  private shouldClip(pointCloud: PointCloudOctree, boundingBox: Box3): boolean {\r\n    const material = pointCloud.material;\r\n\r\n    if (material.numClipBoxes === 0 || material.clipMode !== ClipMode.CLIP_OUTSIDE) {\r\n      return false;\r\n    }\r\n\r\n    const box2 = boundingBox.clone();\r\n    pointCloud.updateMatrixWorld(true);\r\n    box2.applyMatrix4(pointCloud.matrixWorld);\r\n\r\n    const clipBoxes = material.clipBoxes;\r\n    for (let i = 0; i < clipBoxes.length; i++) {\r\n      const clipMatrixWorld = clipBoxes[i].matrix;\r\n      const clipBoxWorld = new Box3(\r\n        new Vector3(-0.5, -0.5, -0.5),\r\n        new Vector3(0.5, 0.5, 0.5),\r\n      ).applyMatrix4(clipMatrixWorld);\r\n      if (box2.intersectsBox(clipBoxWorld)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateVisibilityStructures = (() => {\r\n    const frustumMatrix = new Matrix4();\r\n    const inverseWorldMatrix = new Matrix4();\r\n    const cameraMatrix = new Matrix4();\r\n\r\n    return (\r\n      pointClouds: PointCloudOctree[],\r\n      camera: Camera,\r\n    ): {\r\n      frustums: Frustum[];\r\n      cameraPositions: Vector3[];\r\n      priorityQueue: BinaryHeap<QueueItem>;\r\n    } => {\r\n      const frustums: Frustum[] = [];\r\n      const cameraPositions: Vector3[] = [];\r\n      const priorityQueue = new BinaryHeap<QueueItem>(x => 1 / x.weight);\r\n\r\n      for (let i = 0; i < pointClouds.length; i++) {\r\n        const pointCloud = pointClouds[i];\r\n\r\n        if (!pointCloud.initialized()) {\r\n          continue;\r\n        }\r\n\r\n        pointCloud.numVisiblePoints = 0;\r\n        pointCloud.visibleNodes = [];\r\n        pointCloud.visibleGeometry = [];\r\n\r\n        camera.updateMatrixWorld(false);\r\n\r\n        // Furstum in object space.\r\n        const inverseViewMatrix = camera.matrixWorldInverse;\r\n        const worldMatrix = pointCloud.matrixWorld;\r\n        frustumMatrix\r\n          .identity()\r\n          .multiply(camera.projectionMatrix)\r\n          .multiply(inverseViewMatrix)\r\n          .multiply(worldMatrix);\r\n        frustums.push(new Frustum().setFromProjectionMatrix(frustumMatrix));\r\n\r\n        // Camera position in object space\r\n        inverseWorldMatrix.copy(worldMatrix).invert();\r\n        cameraMatrix\r\n          .identity()\r\n          .multiply(inverseWorldMatrix)\r\n          .multiply(camera.matrixWorld);\r\n        cameraPositions.push(new Vector3().setFromMatrixPosition(cameraMatrix));\r\n\r\n        if (pointCloud.visible && pointCloud.root !== null) {\r\n          const weight = Number.MAX_VALUE;\r\n          priorityQueue.push(new QueueItem(i, weight, pointCloud.root));\r\n        }\r\n\r\n        // Hide any previously visible nodes. We will later show only the needed ones.\r\n        if (isTreeNode(pointCloud.root)) {\r\n          pointCloud.hideDescendants(pointCloud?.root?.sceneNode);\r\n        }\r\n\r\n        for (const boundingBoxNode of pointCloud.boundingBoxNodes) {\r\n          boundingBoxNode.visible = false;\r\n        }\r\n      }\r\n\r\n      return { frustums, cameraPositions, priorityQueue };\r\n    };\r\n  })();\r\n}\r\n"],"names":["QueueItem","pointCloudIndex","weight","node","parent","Potree","DEFAULT_POINT_BUDGET","Vector2","MAX_NUM_NODES_LOADING","FEATURES","LRU","frustumMatrix","Matrix4","inverseWorldMatrix","cameraMatrix","pointClouds","camera","frustums","cameraPositions","priorityQueue","BinaryHeap","x","i","pointCloud","inverseViewMatrix","worldMatrix","Frustum","Vector3","isTreeNode","_a","boundingBoxNode","url","getUrl","xhrRequest","input","init","loadPOC","geometry","PointCloudOctree","loadOctree","renderer","result","ray","params","PointCloudOctreePicker","value","numVisiblePoints","visibleNodes","unloadedGeometry","loadedToGPUThisFrame","exceededMaxLoadsToGPU","nodeLoadFailed","queueItem","maxLevel","parentNode","isGeometryNode","MAX_LOADS_TO_GPU","halfHeight","numNodesToLoad","nodeLoadPromises","sceneNode","cameraPosition","children","child","sphere","distance","radius","projectionFactor","PERSPECTIVE_CAMERA","fov","slope","orthographic","screenPixelRadius","boxHelper","Box3Helper","boundingBox","material","ClipMode","box2","clipBoxes","clipMatrixWorld","clipBoxWorld","Box3"],"mappings":"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"}