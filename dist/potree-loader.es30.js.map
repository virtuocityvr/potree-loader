{"version":3,"file":"potree-loader.es30.js","sources":["../src/loading2/OctreeLoader.ts"],"sourcesContent":["import { XhrRequest } from './../loading/types';\r\nimport { BufferAttribute, BufferGeometry, Vector3 } from \"three\";\r\nimport {PointAttribute, PointAttributes, PointAttributeTypes} from \"./PointAttributes\";\r\nimport { Box3, Sphere } from \"three\";\r\nimport { WorkerPool, WorkerType } from \"./WorkerPool\";\r\nimport { OctreeGeometryNode } from './OctreeGeometryNode';\r\nimport { OctreeGeometry } from './OctreeGeometry';\r\n\r\nexport class NodeLoader{\r\n\r\n\tattributes?: PointAttributes;\r\n\tscale?: [number, number, number];\r\n\toffset?: [number, number, number];\r\n\t\r\n\r\n\tconstructor(public url:string, public workerPool:WorkerPool, public metadata: Metadata){\r\n\t}\r\n\r\n\tasync load(node: OctreeGeometryNode){\r\n\r\n\t\tif(node.loaded || node.loading){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tnode.loading = true;\r\n\t\t// TODO: Need to put the numNodesLoading to the pco\r\n\t\tnode.octreeGeometry.numNodesLoading++;\r\n\r\n\t\ttry{\r\n\t\t\tif(node.nodeType === 2){ // TODO: Investigate\r\n\t\t\t\tawait this.loadHierarchy(node);\r\n\t\t\t}\r\n\r\n\t\t\tlet {byteOffset, byteSize} = node;\r\n\t\t\t\r\n\t\t\tif (byteOffset === undefined || byteSize === undefined) {\r\n\t\t\t\tthrow new Error(\"byteOffset and byteSize are required\");\r\n\t\t\t}\r\n\r\n\t\t\tlet urlOctree = `${this.url}/../octree.bin`;\r\n\r\n\t\t\tlet first = byteOffset;\r\n\t\t\tlet last = byteOffset + byteSize - BigInt(1);\r\n\r\n\t\t\tlet buffer;\r\n\r\n\t\t\tif(byteSize === BigInt(0)){\r\n\t\t\t\tbuffer = new ArrayBuffer(0);\r\n\t\t\t\tconsole.warn(`loaded node with 0 bytes: ${node.name}`);\r\n\t\t\t}else{\r\n\t\t\t\tlet response = await fetch(urlOctree, {\r\n\t\t\t\t\theaders: {\r\n\t\t\t\t\t\t'content-type': 'multipart/byteranges',\r\n\t\t\t\t\t\t'Range': `bytes=${first}-${last}`,\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\r\n\t\t\t\tbuffer = await response.arrayBuffer();\r\n\t\t\t}\r\n\r\n\t\t\tconst workerType = (this.metadata.encoding === \"BROTLI\") ? WorkerType.DECODER_WORKER_BROTLI : WorkerType.DECODER_WORKER;\r\n\t\t\tconst worker = this.workerPool.getWorker(workerType)\r\n\r\n\t\t\tworker.onmessage = (e) => {\r\n\r\n\t\t\t\tlet data = e.data;\r\n\t\t\t\tlet buffers = data.attributeBuffers;\r\n\r\n\t\t\t\tthis.workerPool.returnWorker(workerType, worker);\r\n\r\n\t\t\t\tlet geometry = new BufferGeometry();\r\n\t\t\t\t\r\n\t\t\t\tfor(let property in buffers){\r\n\r\n\t\t\t\t\tlet buffer = buffers[property].buffer;\r\n\r\n\t\t\t\t\tif(property === \"position\"){\r\n\t\t\t\t\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(buffer), 3));\r\n\t\t\t\t\t}else if(property === \"rgba\"){\r\n\t\t\t\t\t\tgeometry.setAttribute('rgba', new BufferAttribute(new Uint8Array(buffer), 4, true));\r\n\t\t\t\t\t}else if(property === \"NORMAL\"){\r\n\t\t\t\t\t\t//geometry.setAttribute('rgba', new BufferAttribute(new Uint8Array(buffer), 4, true));\r\n\t\t\t\t\t\tgeometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\r\n\t\t\t\t\t}else if (property === \"INDICES\") {\r\n\t\t\t\t\t\tlet bufferAttribute = new BufferAttribute(new Uint8Array(buffer), 4);\r\n\t\t\t\t\t\tbufferAttribute.normalized = true;\r\n\t\t\t\t\t\tgeometry.setAttribute('indices', bufferAttribute);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tconst bufferAttribute: BufferAttribute & {\r\n\t\t\t\t\t\t\tpotree?: object\r\n\t\t\t\t\t\t} = new BufferAttribute(new Float32Array(buffer), 1);\r\n\r\n\t\t\t\t\t\tlet batchAttribute = buffers[property].attribute;\r\n\t\t\t\t\t\tbufferAttribute.potree = {\r\n\t\t\t\t\t\t\toffset: buffers[property].offset,\r\n\t\t\t\t\t\t\tscale: buffers[property].scale,\r\n\t\t\t\t\t\t\tpreciseBuffer: buffers[property].preciseBuffer,\r\n\t\t\t\t\t\t\trange: batchAttribute.range,\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tgeometry.setAttribute(property, bufferAttribute);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// indices ??\r\n\r\n\t\t\t\tnode.density = data.density;\r\n\t\t\t\tnode.geometry = geometry;\r\n\t\t\t\tnode.loaded = true;\r\n\t\t\t\tnode.loading = false;\r\n\t\t\t\t// Potree.numNodesLoading--;\r\n\t\t\t\tnode.octreeGeometry.numNodesLoading--;\r\n\t\t\t};\r\n\r\n\t\t\tlet pointAttributes = node.octreeGeometry.pointAttributes;\r\n\t\t\tlet scale = node.octreeGeometry.scale;\r\n\r\n\t\t\tlet box = node.boundingBox;\r\n\t\t\tlet min = node.octreeGeometry.offset.clone().add(box.min);\r\n\t\t\tlet size = box.max.clone().sub(box.min);\r\n\t\t\tlet max = min.clone().add(size);\r\n\t\t\tlet numPoints = node.numPoints;\r\n\r\n\t\t\tlet offset = node.octreeGeometry.loader.offset;\r\n\r\n\t\t\tlet message = {\r\n\t\t\t\tname: node.name,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tpointAttributes: pointAttributes,\r\n\t\t\t\tscale: scale,\r\n\t\t\t\tmin: min,\r\n\t\t\t\tmax: max,\r\n\t\t\t\tsize: size,\r\n\t\t\t\toffset: offset,\r\n\t\t\t\tnumPoints: numPoints\r\n\t\t\t};\r\n\r\n\t\t\tworker.postMessage(message, [message.buffer]);\r\n\t\t}catch(e){\r\n\t\t\tnode.loaded = false;\r\n\t\t\tnode.loading = false;\r\n\t\t\tnode.octreeGeometry.numNodesLoading--;\r\n\r\n\t\t\t// console.log(`failed to load ${node.name}`);\r\n\t\t\t// console.log(e);\r\n\t\t\t// console.log(`trying again!`);\r\n\t\t}\r\n\t}\r\n\r\n\tparseHierarchy(node:OctreeGeometryNode, buffer:ArrayBuffer){\r\n\r\n\t\tlet view = new DataView(buffer);\r\n\r\n\t\tlet bytesPerNode = 22;\r\n\t\tlet numNodes = buffer.byteLength / bytesPerNode;\r\n\r\n\t\tlet octree = node.octreeGeometry;\r\n\t\t// let nodes = [node];\r\n\t\tlet nodes: OctreeGeometryNode[] = new Array(numNodes);\r\n\t\tnodes[0] = node;\r\n\t\tlet nodePos = 1;\r\n\r\n\t\tfor(let i = 0; i < numNodes; i++){\r\n\t\t\tlet current = nodes[i];\r\n\r\n\t\t\tlet type = view.getUint8(i * bytesPerNode + 0);\r\n\t\t\tlet childMask = view.getUint8(i * bytesPerNode + 1);\r\n\t\t\tlet numPoints = view.getUint32(i * bytesPerNode + 2, true);\r\n\t\t\tlet byteOffset = view.getBigInt64(i * bytesPerNode + 6, true);\r\n\t\t\tlet byteSize = view.getBigInt64(i * bytesPerNode + 14, true);\r\n\r\n\t\t\t// if(byteSize === 0n){\r\n\t\t\t// \t// debugger;\r\n\t\t\t// }\r\n\r\n\r\n\t\t\tif(current.nodeType === 2){\r\n\t\t\t\t// replace proxy with real node\r\n\t\t\t\tcurrent.byteOffset = byteOffset;\r\n\t\t\t\tcurrent.byteSize = byteSize;\r\n\t\t\t\tcurrent.numPoints = numPoints;\r\n\t\t\t}else if(type === 2){\r\n\t\t\t\t// load proxy\r\n\t\t\t\tcurrent.hierarchyByteOffset = byteOffset;\r\n\t\t\t\tcurrent.hierarchyByteSize = byteSize;\r\n\t\t\t\tcurrent.numPoints = numPoints;\r\n\t\t\t}else{\r\n\t\t\t\t// load real node \r\n\t\t\t\tcurrent.byteOffset = byteOffset;\r\n\t\t\t\tcurrent.byteSize = byteSize;\r\n\t\t\t\tcurrent.numPoints = numPoints;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcurrent.nodeType = type;\r\n\r\n\t\t\tif(current.nodeType === 2){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tfor(let childIndex = 0; childIndex < 8; childIndex++){\r\n\t\t\t\tlet childExists = ((1 << childIndex) & childMask) !== 0;\r\n\r\n\t\t\t\tif(!childExists){\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet childName = current.name + childIndex;\r\n\r\n\t\t\t\tlet childAABB = createChildAABB(current.boundingBox, childIndex);\r\n\t\t\t\tlet child = new OctreeGeometryNode(childName, octree, childAABB);\r\n\t\t\t\tchild.name = childName;\r\n\t\t\t\tchild.spacing = current.spacing / 2;\r\n\t\t\t\tchild.level = current.level + 1;\r\n\r\n\t\t\t\t(current.children as any)[childIndex] = child;\r\n\t\t\t\tchild.parent = current;\r\n\r\n\t\t\t\t// nodes.push(child);\r\n\t\t\t\tnodes[nodePos] = child;\r\n\t\t\t\tnodePos++;\r\n\t\t\t}\r\n\r\n\t\t\t// if((i % 500) === 0){\r\n\t\t\t// \tyield;\r\n\t\t\t// }\r\n\t\t}\r\n\r\n\t\t// if(duration > 20){\r\n\t\t// \tlet msg = `duration: ${duration}ms, numNodes: ${numNodes}`;\r\n\t\t// \tconsole.log(msg);\r\n\t\t// }\r\n\t}\r\n\r\n\tasync loadHierarchy(node: OctreeGeometryNode){\r\n\r\n\t\tlet {hierarchyByteOffset, hierarchyByteSize} = node;\r\n\r\n\t\tif (hierarchyByteOffset === undefined || hierarchyByteSize === undefined) {\r\n\t\t\tthrow new Error(`hierarchyByteOffset and hierarchyByteSize are undefined for node ${node.name}`);\r\n\t\t}\r\n\r\n\t\tlet hierarchyPath = `${this.url}/../hierarchy.bin`;\r\n\t\t\r\n\t\tlet first = hierarchyByteOffset;\r\n\t\tlet last = first + hierarchyByteSize - BigInt(1);\r\n\r\n\t\tlet response = await fetch(hierarchyPath, {\r\n\t\t\theaders: {\r\n\t\t\t\t'content-type': 'multipart/byteranges',\r\n\t\t\t\t'Range': `bytes=${first}-${last}`,\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\tlet buffer = await response.arrayBuffer();\r\n\r\n\t\tthis.parseHierarchy(node, buffer);\r\n\t}\r\n\r\n}\r\n\r\nlet tmpVec3 = new Vector3();\r\nfunction createChildAABB(aabb:Box3, index:number){\r\n\tlet min = aabb.min.clone();\r\n\tlet max = aabb.max.clone();\r\n\tlet size = tmpVec3.subVectors(max, min);\r\n\r\n\tif ((index & 0b0001) > 0) {\r\n\t\tmin.z += size.z / 2;\r\n\t} else {\r\n\t\tmax.z -= size.z / 2;\r\n\t}\r\n\r\n\tif ((index & 0b0010) > 0) {\r\n\t\tmin.y += size.y / 2;\r\n\t} else {\r\n\t\tmax.y -= size.y / 2;\r\n\t}\r\n\t\r\n\tif ((index & 0b0100) > 0) {\r\n\t\tmin.x += size.x / 2;\r\n\t} else {\r\n\t\tmax.x -= size.x / 2;\r\n\t}\r\n\r\n\treturn new Box3(min, max);\r\n}\r\n\r\nlet typenameTypeattributeMap = {\r\n\t\"double\": PointAttributeTypes.DATA_TYPE_DOUBLE,\r\n\t\"float\": PointAttributeTypes.DATA_TYPE_FLOAT,\r\n\t\"int8\": PointAttributeTypes.DATA_TYPE_INT8,\r\n\t\"uint8\": PointAttributeTypes.DATA_TYPE_UINT8,\r\n\t\"int16\": PointAttributeTypes.DATA_TYPE_INT16,\r\n\t\"uint16\": PointAttributeTypes.DATA_TYPE_UINT16,\r\n\t\"int32\": PointAttributeTypes.DATA_TYPE_INT32,\r\n\t\"uint32\": PointAttributeTypes.DATA_TYPE_UINT32,\r\n\t\"int64\": PointAttributeTypes.DATA_TYPE_INT64,\r\n\t\"uint64\": PointAttributeTypes.DATA_TYPE_UINT64,\r\n}\r\n\r\ntype AttributeType = keyof typeof typenameTypeattributeMap;\r\n\r\nexport interface Attribute {\r\n\tname: string;\r\n\tdescription: string;\r\n\tsize: number;\r\n\tnumElements: number;\r\n\ttype: AttributeType;\r\n\tmin: number[];\r\n\tmax: number[];\r\n}\r\n\r\nexport interface Metadata {\r\n\tversion: string;\r\n\tname: string;\r\n\tdescription: string;\r\n\tpoints: number;\r\n\tprojection: string;\r\n\thierarchy: {\r\n\t\tfirstChunkSize: number;\r\n\t\tstepSize: number;\r\n\t\tdepth: number;\r\n\t},\r\n\toffset: [number, number, number],\r\n\tscale: [number, number, number],\r\n\tspacing: number,\r\n\tboundingBox: {\r\n\t\tmin: [number, number, number],\r\n\t\tmax: [number, number, number],\r\n\t},\r\n\tencoding: string;\r\n\tattributes: Attribute[];\r\n}\r\n\r\nexport class OctreeLoader{\r\n\r\n\tworkerPool: WorkerPool = new WorkerPool();\r\n\r\n\tconstructor() {\r\n\t}\r\n\r\n\tstatic parseAttributes(jsonAttributes:Attribute[]){\r\n\r\n\t\tlet attributes = new PointAttributes();\r\n\r\n\t\t// Replacements object for string to string\r\n\t\tlet replacements: {[key: string]: string} = {\r\n\t\t\t\"rgb\": \"rgba\",\r\n\t\t};\r\n\r\n\t\tfor (const jsonAttribute of jsonAttributes) {\r\n\t\t\tlet {name, numElements, min, max} = jsonAttribute;\r\n\r\n\t\t\tlet type = typenameTypeattributeMap[jsonAttribute.type]; // Fix the typing, currently jsonAttribute has type \"never\"\r\n\r\n\t\t\tlet potreeAttributeName = replacements[name] ? replacements[name] : name;\r\n\r\n\t\t\tlet attribute = new PointAttribute(potreeAttributeName, type, numElements);\r\n\r\n\t\t\tif(numElements === 1){\r\n\t\t\t\tattribute.range = [min[0], max[0]];\r\n\t\t\t}else{\r\n\t\t\t\tattribute.range = [min, max];\r\n\t\t\t}\r\n\r\n\t\t\tif (name === \"gps-time\") { // HACK: Guard against bad gpsTime range in metadata, see potree/potree#909\r\n\t\t\t\tif (typeof attribute.range[0] === \"number\" && attribute.range[0] === attribute.range[1]) {\r\n\t\t\t\t\tattribute.range[1] += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tattribute.initialRange = attribute.range;\r\n\r\n\t\t\tattributes.add(attribute);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\t// check if it has normals\r\n\t\t\tlet hasNormals = \r\n\t\t\t\tattributes.attributes.find(a => a.name === \"NormalX\") !== undefined &&\r\n\t\t\t\tattributes.attributes.find(a => a.name === \"NormalY\") !== undefined &&\r\n\t\t\t\tattributes.attributes.find(a => a.name === \"NormalZ\") !== undefined;\r\n\r\n\t\t\tif(hasNormals){\r\n\t\t\t\tlet vector = {\r\n\t\t\t\t\tname: \"NORMAL\",\r\n\t\t\t\t\tattributes: [\"NormalX\", \"NormalY\", \"NormalZ\"],\r\n\t\t\t\t};\r\n\t\t\t\tattributes.addVector(vector);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\t}\r\n\r\n\tasync load(url:string, xhrRequest: XhrRequest){ // Previously a static method\r\n\r\n\t\tlet response = await xhrRequest(url);\r\n\t\tlet metadata: Metadata = await response.json();\r\n\r\n\t\tlet attributes = OctreeLoader.parseAttributes(metadata.attributes);\r\n\t\t// console.log(attributes)\r\n\r\n\t\tlet loader = new NodeLoader(url, this.workerPool, metadata);\r\n\t\tloader.attributes = attributes;\r\n\t\tloader.scale = metadata.scale;\r\n\t\tloader.offset = metadata.offset;\r\n\r\n\t\tlet octree = new OctreeGeometry(loader, new Box3(new Vector3(...metadata.boundingBox.min), new Vector3(...metadata.boundingBox.max)));\r\n\t\toctree.url = url;\r\n\t\toctree.spacing = metadata.spacing;\r\n\t\toctree.scale = metadata.scale;\r\n\r\n\t\tlet min = new Vector3(...metadata.boundingBox.min);\r\n\t\tlet max = new Vector3(...metadata.boundingBox.max);\r\n\t\tlet boundingBox = new Box3(min, max);\r\n\r\n\t\tlet offset = min.clone();\r\n\t\tboundingBox.min.sub(offset);\r\n\t\tboundingBox.max.sub(offset);\r\n\r\n\t\toctree.projection = metadata.projection;\r\n\t\toctree.boundingBox = boundingBox;\r\n\t\toctree.tightBoundingBox = boundingBox.clone();\r\n\t\toctree.boundingSphere = boundingBox.getBoundingSphere(new Sphere());\r\n\t\toctree.tightBoundingSphere = boundingBox.getBoundingSphere(new Sphere());\r\n\t\toctree.offset = offset;\r\n\t\toctree.pointAttributes = OctreeLoader.parseAttributes(metadata.attributes);\r\n\r\n\t\tlet root = new OctreeGeometryNode(\"r\", octree, boundingBox);\r\n\t\troot.level = 0;\r\n\t\troot.nodeType = 2;\r\n\t\troot.hierarchyByteOffset = BigInt(0);\r\n\t\troot.hierarchyByteSize = BigInt(metadata.hierarchy.firstChunkSize);\r\n\t\troot.spacing = octree.spacing;\r\n\t\troot.byteOffset = BigInt(0); // Originally 0\r\n\r\n\t\toctree.root = root;\r\n\r\n\t\tloader.load(root);\r\n\r\n\t\tlet result = {\r\n\t\t\tgeometry: octree,\r\n\t\t};\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n};"],"names":["NodeLoader","url","workerPool","metadata","node","byteOffset","byteSize","urlOctree","first","last","buffer","workerType","WorkerType","worker","e","data","buffers","geometry","BufferGeometry","property","BufferAttribute","bufferAttribute","batchAttribute","pointAttributes","scale","box","min","size","max","numPoints","offset","message","view","bytesPerNode","numNodes","octree","nodes","nodePos","i","current","type","childMask","childIndex","childName","childAABB","createChildAABB","child","OctreeGeometryNode","hierarchyByteOffset","hierarchyByteSize","hierarchyPath","tmpVec3","Vector3","aabb","index","Box3","typenameTypeattributeMap","PointAttributeTypes","OctreeLoader","WorkerPool","jsonAttributes","attributes","PointAttributes","replacements","jsonAttribute","name","numElements","potreeAttributeName","attribute","PointAttribute","vector","xhrRequest","loader","OctreeGeometry","boundingBox","Sphere","root"],"mappings":"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"}